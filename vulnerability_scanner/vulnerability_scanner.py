import requests
from bs4 import BeautifulSoup
import re

YELLOW = '\033[93m'
BLUE = '\033[94m'
RESET = '\033[0m'


# Test for Broken Authentication/Session Fixation
def test_broken_authentication(login_url, logout_url, login_data, session):
    print(f"\n{BLUE}Testing for CWE-384: Session Fixation / Broken Authentication...{RESET}")

    # Step 1: Capture the session cookie before login
    pre_login_response = session.get(login_url)
    pre_login_cookie = session.cookies.get('informationpoint_session')
    print(f"Session cookie before login: {pre_login_cookie}")

    # Step 2: Log in and capture the session cookie after login
    login_response = session.post(login_url, data=login_data)
    post_login_cookie = session.cookies.get('informationpoint_session')
    print(f"Session cookie after login: {post_login_cookie}")

    # Step 3: Compare the session cookie before and after login
    if pre_login_cookie == post_login_cookie:
        print(
            f"{YELLOW}ATTENTION: Session Fixation Vulnerability Detected! (Session ID did not change after login){RESET}")
    else:
        print("Session cookie changed after login (no immediate fixation vulnerability detected)")

    # Step 4: Log out and capture the session cookie after logout
    logout_response = session.get(logout_url)
    post_logout_cookie = session.cookies.get('informationpoint_session')
    print(f"Session cookie after logout: {post_logout_cookie}")

    # Step 5: Check if the session cookie is invalidated after logout
    if post_logout_cookie == post_login_cookie:
        print(
            f"{YELLOW}ATTENTION: Session Fixation Vulnerability Detected! (Session cookie is still valid after logout){RESET}")
    else:
        print("Session cookie was invalidated after logout (no fixation vulnerability detected)")


# Test for CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute and Missing HttpOnly
def test_sensitive_cookie_attributes(url, session):
    print(
        f"\n{BLUE}Testing for CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' and 'HttpOnly' Attributes...{RESET}")

    # Capture cookies after login
    response = session.get(url)
    for cookie in session.cookies:
        cookie_name = cookie.name
        cookie_secure = cookie.secure
        cookie_httponly = cookie.has_nonstandard_attr('HttpOnly')

        # Check if "Secure" attribute is missing
        if not cookie_secure:
            print(f"{YELLOW}ATTENTION: Cookie '{cookie_name}' is missing 'Secure' attribute!{RESET}")

        # Check if "HttpOnly" attribute is missing
        if not cookie_httponly:
            print(f"{YELLOW}ATTENTION: Cookie '{cookie_name}' is missing 'HttpOnly' attribute!{RESET}")


# Test for CWE-352: Cross-Site Request Forgery (CSRF)
def test_csrf_protection(url, session):
    print(f"\n{BLUE}Testing for CWE-352: Cross-Site Request Forgery (CSRF)...{RESET}")

    # Check if the login page has a CSRF token
    response = session.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')

    # Look for hidden CSRF token fields in forms
    csrf_token = None
    for input_tag in soup.find_all('input'):
        if 'csrf' in input_tag.get('name', '').lower() or 'token' in input_tag.get('name', '').lower():
            csrf_token = input_tag.get('value')
            print(f"CSRF Token found in form: {csrf_token}")
            break

    if not csrf_token:
        print(f"{YELLOW}ATTENTION: No CSRF token found in form!{RESET}")

    # Optionally, simulate a CSRF attack by making a POST request without the CSRF token
    fake_data = {"username": "user", "password": "pass"}  # Example data
    headers = {"Referer": url}  # CSRF attack usually relies on missing or incorrect Referer header

    fake_response = session.post(url, data=fake_data, headers=headers)

    # Check if the response shows that the request was accepted
    if fake_response.status_code == 200:
        print(f"{YELLOW}ATTENTION: Potential CSRF vulnerability! Request accepted without CSRF token.{RESET}")
    else:
        print("CSRF protection seems to be in place (request denied without valid CSRF token).")


# Test for Account/Username Enumeration
def test_account_enumeration(url, session, test_usernames):
    print(f"\n{BLUE}Testing for Account Enumeration/Username Enumeration...{RESET}")

    for username in test_usernames:
        # Construct the URL path with the username, e.g., /profile/admin
        profile_url = f"{url}/{username}"

        # Make a GET request to the constructed profile URL
        response = session.get(profile_url)

        # Check if the status code is anything other than 404
        if response.status_code != 404:
            print(
                f"{YELLOW}ATTENTION: Possible Username Enumeration Detected for '{username}' - Status Code: {response.status_code}{RESET}")
        else:
            print(f"Username '{username}' - Status Code: {response.status_code} (No Enumeration Detected)")


# Test for Information Disclosure
def test_information_disclosure(url, session):
    print(f"\n{BLUE}Testing for Information Disclosure / Unprotected access...{RESET}")

    # List of known sensitive files and directories to check for
    sensitive_files = [
        "CHANGELOG.txt", "README.txt", "robots.txt", "humans.txt", "console",
        "web.config", ".git", ".viminfo", ".rhosts", ".rhost", ".profile",
        ".maintenance", ".kde", ".ftp", ".canna", ".backup", ".svn",
        "config.php", "wp-config.php", "composer.json", "composer.lock",
        "package.json", ".env", ".htaccess", ".htpasswd", "docker-compose.yml",
        "Dockerfile", "id_rsa", "id_rsa.pub", "keys.json", "db_backup.sql",
        ".bash_history", "phpinfo.php", ".ssh", ".bashrc", ".bash_profile",
        "server-status", "server-info"
    ]

    # Check each file or directory for accessibility
    for file in sensitive_files:
        file_url = f"{url}/{file}"
        response = session.get(file_url)

        # If the file is accessible (status code 200), it might be leaking sensitive information
        if response.status_code == 200:
            print(f"{YELLOW}Information Disclosure Detected: {file_url} is accessible.{RESET}")


# Main function
def main():
    # Define the target URL and login credentials (for authentication tests)
    url = "https://e8d8d4bd-8f81-48b3-bcea-911853db0921.i.vuln.land/"
    login_url = url + "/login"
    logout_url = url + "/logout"
    form_url = url + "/submit"
    profile_url = url + "/profile"
    login_data = {"username": "corwin.louisa@example.com", "password": "user1234"}
    test_usernames = ["admin", "user", "test", "corwin.louisa@example.com", "sadie.isobel@example.com", "1", "2", "3"]

    # Create a session to persist cookies across requests
    session = requests.Session()

    # Run tests
    test_broken_authentication(login_url, logout_url, login_data, session)
    test_sensitive_cookie_attributes(url, session)
    test_csrf_protection(form_url, session)  # Test CSRF
    test_account_enumeration(profile_url, session, test_usernames)
    test_information_disclosure(url, session)


if __name__ == "__main__":
    main()
